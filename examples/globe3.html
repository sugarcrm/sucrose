<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=320" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>Globe Chart</title>
    <link rel="stylesheet" href="css/sucrose.min.css">
    <link rel="stylesheet" href="css/examples.min.css">
    <style>
      #globe {
        max-width: 700px;
        height: 500px;
      }
      svg {
        pointer-events: all;
      }
      circle {
        fill: #dbe4f0;
      }
      path {
        fill: #aaa;
        stroke: #fff;
      }
      .globe {
        fill: #6699cc;
        fill-opacity: .5;
      }
    </style>
  </head>
  <body class="full-screen">
    <div class="sc-demo">
      <div id="globe" class="sc-chart sc-chart-globe">
        <svg></svg>
      </div>
    </div>

<script src="js/jquery-2.1.4.min.js"></script>
<script src="js/lib.min.js"></script>
<script src="js/sugar.min.js"></script>
<script src="js/jquerymy.min.js"></script>

<script src="js/d3.min.js"></script>
<script src="js/topojson.min.js"></script>
<script src="js/sucrose.min.js"></script>

<script>


  var results = {
        "USA": {
          "_total": 152916.55555556,
          "US-NY": {
            "_total": 54831.333333333
          },
          "US-CA": {
            "_total": 98085.222222222
          }
        }
      },
      svgId = '#globe svg',
      autoSpin = false,
      margin = {top: 10, right: 10, bottom: 10, left: 10};

  // Calculate the maximum balue so that we can generate a colour scale.
  var colorRange = function (r) {
          var max = d3.max(d3.values(r));
          return d3.scale.linear().domain([0, max]).range(['#99CCFF', '#336699']);
      },
      color = colorRange(results),
      fill = function (d) {
          var r = amount(d);
          return r ? color(r) : '';
      };

  var m0,
      o0,
      t0,
      countries,
      active_country = false,
      world_map = [],
      country_map = {},
      country_label = {},
      world_view = {rotate: [100, -10], scale: 1, zoom: 1},
      country_view = {rotate: [null, null], scale: null, zoom: null},
      node = this.$(svgId),
      width = parseInt(node.width(), 10) - margin.left - margin.right,
      height = parseInt(node.height(), 10) - margin.top - margin.top,
      iRotation,
      dispatch = d3.dispatch('tooltipShow', 'tooltipHide'),
      tooltips = true,
      tooltip = null;

  //============================================================

  var projection = d3.geo.orthographic()
        .scale(Math.min(height, width) * 1 / 2)
        .translate([width / 2 + margin.left, height / 2 + margin.top])
        .clipAngle(90)
        .precision(0.1)
        .rotate(world_view.rotate);

  var path = d3.geo.path()
        .projection(projection);

  var graticule = d3.geo.graticule();

  var svg = d3.select(svgId)
        .attr('width', width)
        .attr('height', height)
        .on('mousedown', mousedown);

      svg.append('path')
          .datum({type: 'Sphere'})
          .attr('class', 'sphere')
          .attr('d', path);

  // zoom and pan
  var zoom = d3.behavior.zoom()
      .on('zoom', function () {
          projection.scale((Math.min(height, width) * Math.min(Math.max(d3.event.scale, 0.75), 3)) / 2);
          refresh();
      });

  svg.call(zoom);

  queue()
    .defer(d3.json, 'data/geo/world-countries-topo-110.json')
    .defer(d3.json, 'data/geo/usa-states-topo-110.json')
    .defer(d3.json, 'data/geo/cldr_en.json')
    .await(function (error, world, country, labels) {
      if (error) {
        return;
      }

      world_map = topojson.feature(world, world.objects.countries).features;
      country_map['USA'] = topojson.feature(country, country.objects.states).features;
      country_label = labels;

      loadChart(world_map, 'countries');
      if (autoSpin) {
          iRotation = setInterval(spin, 10);
      }
    });

  d3.select('.sphere')
    .on('click', function () {
      unLoadCountry();
    });


  function loadChart(data, classes) {

      countries = svg.append('g')
          .attr('class', classes)
        .selectAll('path')
          .data(data)
        .enter().append('path')
          .attr('d', clip)
          .style('fill', fill);

      countries.on('click', function (d) {
          if (active_country != d3.select(this)) {

              unLoadCountry();

              // If we have country-specific geographic features.
              if (country_map[d.id]) {

                  if (tooltips) {
                    sucrose.tooltip.cleanup();
                  }

                  world_view = {
                      rotate: projection.rotate(),
                      scale: projection.scale(),
                      zoom: zoom.scale()
                  };

                  var centroid = d3.geo.centroid(d);
                  projection.rotate([-centroid[0], -centroid[1]]);

                  var bounds = path.bounds(d);
                  var hscale = width  / (bounds[1][0] - bounds[0][0]);
                  var vscale = height / (bounds[1][1] - bounds[0][1]);

                  if (width * hscale < height * vscale) {
                      projection.scale(width * hscale / 2);
                      zoom.scale(hscale);
                  } else {
                      projection.scale(height * vscale / 2);
                      zoom.scale(vscale);
                  }

                  country_view = {
                      rotate: projection.rotate(),
                      scale: projection.scale(),
                      zoom: zoom.scale()
                  };

                  // Flatten the results and include the state-level
                  // results so that we don't need complex tooltip logic.
                  var obj = region_results(d);
                  obj.parent = results;
                  results = obj;

                  color = colorRange(results);

                  active_country = d3.select(this);

                  loadChart(country_map[d.id], 'states');

                  active_country.style('display', 'none');

                  refresh();
              }
          }
      });

      countries.on('mouseover', function (d) {
          mouseover(d);
      });

      countries.on('mouseout', function () {
          mouseout();
      });
  }

  function unLoadCountry() {
      if (active_country) {
          results = results.parent;
          active_country.style('display', 'inline');
          color = colorRange(results);
          d3.select('.states').remove();
          active_country = false;
          country_view = {rotate: [null, null], scale: null, zoom: null};
          projection.rotate(world_view.rotate);
          projection.scale(world_view.scale);
          zoom.scale(world_view.zoom);
          refresh();
      }
  }

  function region_results(d) {
      if (results[d.id]) {
          return results[d.id];
      } else if (results[d.properties.name]) {
          return results[d.properties.name];
      }
  }

  function amount(d) {
      var result = region_results(d);
      if (result) {
          return result._total;
      }
      return 0;
  }

  function tooltipContent(d) {
      return '<p><b>' + d.name + '</b></p>' +
             '<p><b>Amount:</b> $' + d3.format(',.0f')(d.amount) + '</p>';
  }

  function showTooltip(eo, offsetElement) {
      // New addition to calculate position if SVG is scaled with viewBox, may move
      // TODO: consider implementing everywhere else
      var offsets = {left: 0, right: 0};

      if (offsetElement) {
          var svg = d3.select(offsetElement).select('svg'),
              viewBox = svg.attr('viewBox');
          offsets = sucrose.utils.getAbsoluteXY(offsetElement);
          if (viewBox) {
              viewBox = viewBox.split(' ');
              var ratio = parseInt(svg.style('width'), 10) / viewBox[2];
              eo.pos[0] = eo.pos[0] * ratio;
              eo.pos[1] = eo.pos[1] * ratio;
          }
      }

      var left = eo.pos[0] + (offsets.left || 0) + margin.left,
          top = eo.pos[1] + (offsets.top || 0) + margin.top,
          content = tooltipContent(eo);

      tooltip = sucrose.tooltip.show([left, top], content, null, null, offsetElement);
  };

  function mouseover(d) {
      if (tooltips) {
          var eo = {
              pos: [d3.event.pageX, d3.event.pageY],
              name: (country_label[d.properties.iso_a2] || d.properties.name),
              amount: amount(d)
          };
          showTooltip(eo, svg.node().parentNode);
      }
  }

  function mouseout() {
      if (tooltips) sucrose.tooltip.cleanup();
  }

  function mousedown() {
      m0 = [d3.event.pageX, d3.event.pageY];
      o0 = projection.rotate();
      d3.event.preventDefault();
      if (tooltips) {
        sucrose.tooltip.cleanup();
      }
      if (autoSpin) {
          clearInterval(iRotation);
      }
  }

  function mousemove() {
      if (tooltip) {
          var pos = [d3.event.pageX, d3.event.pageY];
          // sucrose.tooltip.position(tooltip, pos);
          sucrose.tooltip.position(svg.node().parentNode, tooltip, d3.event);
      }
      if (m0) {
          var m1 = [d3.event.pageX, d3.event.pageY],
              //o1 = [o0[0] + (m0[0] - m1[0]) / 4, o0[1] - (m0[1] - m1[1]) / 4];
              o1 = [o0[0] - (m0[0] - m1[0]) / 4, (country_view.rotate[1] || world_view.rotate[1])];
          rotate(o1);
      }
  }

  function mouseup() {
      if (m0) {
          mousemove();
          m0 = null;
      }
  }

  function refresh(duration) {
      svg.selectAll('path').attr('d', clip);
  }

  function clip(d) {
    return path(d) || 'M0,0Z';
  }

  function spin() {
      var o0 = projection.rotate(),
          m1 = [10, 0],
          o1 = [o0[0] + m1[0] / 8, -10];
      rotate(o1);
  }

  function rotate(o) {
      projection.rotate(o);
      refresh();
  }

  function resize() {
      width = parseInt(node.width(), 10) - margin.left - margin.right;
      height = parseInt(node.height(), 10) - margin.top - margin.top;
      projection
          .scale((Math.min(height, width) * Math.min(Math.max(zoom.scale(), 0.75), 3)) / 2)
          .translate([width / 2 + margin.left, height / 2 + margin.top]);
      refresh();
  }

  // Must select window, in case the user lets go of the mouse outside the
  // dashlet's pane.
  d3.select(window)
      .on('mousemove', mousemove)
      .on('mouseup', mouseup);

  sucrose.utils.windowResize(resize);
  sucrose.utils.resizeOnPrint(resize);
</script>
</body>
</html>


